# -*- coding: utf-8 -*-
"""Meteorologia.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HYjSuO_6U1ILmhjGAiLj9Mxfvi5pnjHd

# Modelo predictivo de precipitaciones mensuales en la isla de Tenerife (Canarias)

Determinación de un modelo para la predicción de las precipitaciones acumulada mensual mediante variables meteorologicas. 

> La meteorología (del griego μετέωρον metéōron ‘alto en el cielo’, ‘meteoro’; y λόγος lógos ‘conocimiento’, ‘tratado’) es la ciencia interdisciplinaria, de la física de la atmósfera, que estudia el estado del tiempo, el medio atmosférico, los fenómenos producidos y las leyes que lo rigen. - Wikipedia.

![Isla de Tenerife](https://www.holaislascanarias.com/sites/default/files/tenerife.jpg)
## Fuentes de Datos
1. Datos locales. Obtenidos de estaciones meteorológicas. (Santa Cruz de Tenerife, Tenerife Norte). Conjuntos de datos de los últimos 40 años
2. Datos globales. **Fuentes:** [National Oceanic and Atmospheric Administration (NOAA)](http://www.noaa.gov/). [National Centers for Environmental Prediction (NCEP)](http://http://www.ncep.noaa.gov/). [Advancing global NWP through international collaboration (ECMWF)](https://www.ecmwf.int/)

### Se desarrolló la propuesta con la biblioteca [scikit-learn](http://scikit-learn.org )
"""

import matplotlib.pyplot as plt
import numpy as np
from sklearn import datasets, linear_model
from sklearn.linear_model import LinearRegression, RANSACRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import cross_val_predict
from sklearn.metrics import mean_squared_error, r2_score
from sklearn import model_selection
import pandas as pd
from pandas.tools.plotting import scatter_matrix

"""# Datos locales & globales
---
* Temperatura media mensual(ºC).
* Velocidad viento medio mensual (m/s). 
* Presión media mensual (mBa).
* Humedad relativa mensual (%).
* Precipitación acumulada mensual (mm).
* Temperatura del agua del mar
* Indice NOA
* Presión a 1500 m
* Otras mediciones mensuales
---
*Los datos se descargan desde una carpeta compartida.*
"""

url ="https://www.dropbox.com/s/3nt68pphiazmh2j/Cluster_Python.csv?dl=1"
names = ['year','month','mm_per_month_TFN','temp_mean_TFN', 'ws_mean_TFN','atmos_pres_mean_TFN','rh_mean_TFN','mm_per_month_SC', 'temp_mean_SC','ws_mean_SC','atmos_pres_mean_SC','rh_mean_SC','SST','SLP',
'HGT','NOA', 'max_mm_per_month','fit.cluster']
dataset = pd.read_csv(url, names=names)

print(dataset.shape)

print(dataset.head(5))

"""# Eliminamos algunos datos no necesarios o correlacionados"""

dataset = dataset.drop(labels=["year", "month", "mm_per_month_TFN", "mm_per_month_SC","fit.cluster"], axis=1)

print(dataset.shape)

print(dataset.describe())

"""# Distribución de las precipitaciones"""

dataset.max_mm_per_month.plot(kind='box', subplots=True,  sharex=False, sharey=False, showfliers=True)

plt.show()

dataset.hist()
plt.show()

scatter_matrix(dataset)
plt.show()

"""## Determinación de los datos de entrenamiento y validación
### Se obtuvo dividio el Dataset en 80% de entrenamiento y 20% validación
"""

array = dataset.values
X = array[:,0:12]
Y = array[:,12]
validation_size = 0.20
seed = 123
X_train, X_validation, Y_train, Y_validation = model_selection.train_test_split(X, Y, test_size=validation_size, random_state=seed)

"""## Hacemos una pequeña selección de algoritmos"""

# Spot Check Algorithms
models = []
models.append(('LR', LinearRegression()))
models.append(('DTR', DecisionTreeRegressor()))
models.append(('RANSAC',RANSACRegressor()))
models.append(('RF',RandomForestRegressor(bootstrap=True, criterion='mse', max_depth=2,
           max_features='auto', max_leaf_nodes=None,
           )))
models.append(('RF (LOG)',RandomForestRegressor(bootstrap=True, criterion='mse', max_depth=2,
           max_features='log2', max_leaf_nodes=None,
           )))
models.append(('RF(Sqrt)',RandomForestRegressor(bootstrap=True, criterion='mse', max_depth=2,
           max_features='sqrt', max_leaf_nodes=None,
           )))
models.append(('RF (4)',RandomForestRegressor(bootstrap=True, criterion='mse', max_depth=2,
           max_features=4, max_leaf_nodes=None,
           )))
results = []
names = []
for name, model in models:
    kfold = model_selection.KFold(n_splits=10, random_state=seed)
    cv_results = model_selection.cross_val_score(model, X_train, Y_train, cv=kfold)
    results.append(cv_results)
    names.append(name)
    msg = "%s: %f (%f)" % (name, cv_results.mean(), cv_results.std())
    print(msg)

"""# Valoramos los distintos algoritmos seleccionados"""

# Comparacion de los Algoritmos
fig = plt.figure()
fig.suptitle('Comparación de los algoritmos')
ax = fig.add_subplot(111)
plt.boxplot(results)
ax.set_xticklabels(names)
plt.show()

"""## Se realiza una predicción. Aunque los resultados no son buenos"""

LR = LinearRegression()
LR.fit(X_train, Y_train)
predictions = LR.predict(X_validation)

fig, ax = plt.subplots()
ax.scatter(Y_validation, predictions, edgecolors=(0, 0, 0))
ax.plot([Y_validation.min(), Y_validation.max()], [Y_validation.min(), Y_validation.max()], 'k--', lw=2)
ax.set_xlabel('Medido')
ax.set_ylabel('Predecido')
plt.show()

"""**Los resultados no son del todo satisfactorios por lo que se tendría que trabajar en el preprocesamiento de los datos, emplear meta-algoritmos o ensembles.**"""

print('Coeficientes determinados: \n', LR.coef_)
print("Mean squared error: %.2f"
#       % mean_squared_error(Y_validation, predictions))
print('Variance score: %.2f' % r2_score(Y_validation, predictions))

# Python version
import sys
print('Python: {}'.format(sys.version))
# scipy
import scipy
print('scipy: {}'.format(scipy.__version__))
# numpy
import numpy
print('numpy: {}'.format(numpy.__version__))
# matplotlib
import matplotlib
print('matplotlib: {}'.format(matplotlib.__version__))
# pandas
import pandas
print('pandas: {}'.format(pandas.__version__))
# scikit-learn
import sklearn
print('sklearn: {}'.format(sklearn.__version__))